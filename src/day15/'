// Advent of Code
// Copyright (C) 2018  Isaac Curtis

use hashbrown::HashSet;
use std::fmt::{self, Display};

#[derive(Clone, Copy, Debug, PartialEq)]
enum EntityClass {
    Nothing,
    Wall,
    Elf,
    Goblin,
}

#[derive(Clone, Copy, PartialEq, Debug)]
struct Entity {
    class: EntityClass,
    attack: i32,
    hp: i32,
}

#[derive(Clone, PartialEq, Debug)]
struct World {
    world: Vec<Entity>,
    xsize: usize,
    ysize: usize,
}

impl Display for World {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for y in 0..self.ysize {
            for x in 0..self.xsize {
                write!(f, "{}", self.world[x + y * self.xsize])?;
            }
            write!(f, "\n")?;
        }
        Ok(())
    }
}

impl World {
    fn get_units(&mut self) -> Box<Vec<usize>> {
        let mut units = Vec::new();
        for p in 0..(self.xsize * self.ysize) {
            let class = self.world[p].class;
            if class == EntityClass::Goblin || class == EntityClass::Elf {
                units.push(p);
            }
        }
        return Box::new(units);
    }

    fn get_targets(&mut self, unit: &usize, others: &Vec<usize>) -> Box<Vec<usize>> {
        let mut targets = Vec::new();
        let mut enemy_class = EntityClass::Nothing;
        if self.world[*unit].class == EntityClass::Elf {
            enemy_class = EntityClass::Goblin;
        } else {
            enemy_class = EntityClass::Elf;
        }
        for t in others.iter() {
            if enemy_class == self.world[*t].class {
                targets.push(*t);
            }
        }
        return Box::new(targets);
    }

    fn target_in_range(&mut self, u: &usize, targets: &Vec<usize>) -> Option<usize> {
        for t in targets.iter() {
            if *t == *u - 1 || *t == *u + 1 || *t == *u + self.xsize || *t == *u - self.xsize {
                return Some(*t);
            }
        }
        None
    }

    fn attack(&mut self, unit: &usize, target: &usize) {
        println!(
            "{} {:?} ATTACKS {} {:?}",
            unit, self.world[*unit].class, target, self.world[*target].class
        );
        self.world[*target].hp -= self.world[*unit].attack;
    }

    fn get_adjacent(&mut self, p: &usize) -> Vec<usize> {
        let mut valid = Vec::new();
        for c in [*p + 1, *p - 1, *p + self.xsize, *p - self.xsize].iter() {
            valid.push(*c);
        }
        return valid;
    }

    fn move_to(&mut self, unit: &usize, target: &usize) {
        if self.world[*target].class != EntityClass::Nothing {
            panic!(
                "WE CAN'T MOVE HERE: {:?} cannot move over {:?}",
                self.world[*unit].class, self.world[*target].class
            );
        } else {
            self.world[*target] = self.world[*unit];
            self.world[*unit] = Entity::nothing();
        }
    }

    // Find targets for a player using BFS.  We return a list of candidates, sorted
    // by reading order, and also the direction for the first step if that target is
    // selected.
    fn find_targets(&mut self, pos: &usize) -> (i32, Vec<usize>) {
        let mut positions = vec![(1, None, pos)];
        let mut seen = HashSet::with_capacity(1000);
        seen.insert(pos);
        let mut targets = vec![];
        let mut min = i32::max_value();

        loop {
            let seen_count = seen.len();
            let mut new_positions = vec![];
            for (steps, first, pos) in positions {
                let adjacents = self.get_adjacent(pos);
                for new_pos in adjacents.iter() {
                    let first = first.or_else(|| Some(new_pos));
                    if seen.insert(new_pos) {
                        match self.world[new_pos].class {
                            Empty => {
                                if steps < min {
                                    new_positions.push((steps + 1, first, new_pos))
                                }
                            }
                            v if pos.hates(v) => {
                                targets.push((steps, new_pos, first.unwrap()));
                                min = min.min(steps)
                            }
                            _ => {}
                        }
                    }
                }
            }
            positions = new_positions;
            if seen.len() == seen_count {
                return (
                    min,
                    targets
                        .into_iter()
                        .filter(|c| c.0 == min)
                        .map(|c| (c.1, c.2))
                        .sorted(),
                );
            }
        }
    }
}

impl Entity {
    fn goblin() -> Self {
        Entity {
            class: EntityClass::Goblin,
            attack: 3,
            hp: 200,
        }
    }

    fn elf() -> Self {
        Entity {
            class: EntityClass::Elf,
            attack: 34,
            hp: 200,
        }
    }

    fn wall() -> Self {
        Entity {
            class: EntityClass::Wall,
            attack: -1,
            hp: 200_000,
        }
    }

    fn nothing() -> Self {
        Entity {
            class: EntityClass::Nothing,
            attack: -1,
            hp: 200_000,
        }
    }
}

impl Display for Entity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.class {
            EntityClass::Nothing => write!(f, "."),
            EntityClass::Wall => write!(f, "#"),
            EntityClass::Elf => write!(f, "E"),
            EntityClass::Goblin => write!(f, "G"),
        }
    }
}

#[aoc_generator(day15)]
fn parse_input(input: &str) -> Box<World> {
    const WIDTH: usize = 32;
    const HEIGHT: usize = 32;
    let mut grid = vec![Entity::nothing(); WIDTH * HEIGHT];
    let lines = input.lines();
    for (y, line) in lines.enumerate() {
        for (x, c) in line.chars().enumerate() {
            grid[x + y * WIDTH] = match c {
                '#' => Entity::wall(),
                'E' => Entity::elf(),
                'G' => Entity::goblin(),
                _ => Entity::nothing(),
            };
        }
    }

    return Box::new(World {
        world: grid,
        xsize: WIDTH,
        ysize: HEIGHT,
    });
}

#[aoc(day15, part1)]
fn part1(input: &World) -> usize {
    let mut world = input.clone();
    'game: loop {
        println!("{}", world);
        let units = world.get_units();
        for u in units.iter() {
            let targets = world.get_targets(u, &units);

            if targets.len() == 0 {
                // That's it, we killed em.
                break 'game;
            }

            // Check if in range already
            if let Some(target) = world.target_in_range(u, &targets) {
                world.attack(u, &target);
            } else {
                // Else search for best place to move to
                if let Some(valid_pos) = world.closest_position_in_range_of_target(*u) {
                    world.move_to(u, &valid_pos);
                }
            }
        }
    }
    return 0;
}

#[cfg(test)]
mod test {
    use super::*;

    const INPUT: &str = r#"/->-\
|   |  /----\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/ "#;

    #[test]
    fn test_part1() {
        assert_eq!(part1(&parse_input(INPUT)), Point { x: 7, y: 3 });
    }

    #[test]
    fn test_part2() {
        let input = r#"/>-<\
|   |
| /<+-\
| | | v
\>+</ |
  |   ^
  \<->/"#;
        assert_eq!(part2(&parse_input(input)), Point { x: 6, y: 4 });
    }

}
